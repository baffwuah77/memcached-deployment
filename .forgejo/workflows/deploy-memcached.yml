name: Deploy Memcached with Vault

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/memcached
  VAULT_PATH: secret/Dev-secret/memcached

jobs:
  vault-init:
    name: Initialize Vault Path
    runs-on: ubuntu-latest
    outputs:
      vault-ready: ${{ steps.check.outputs.ready }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Vault CLI
        run: |
          wget -O vault.zip https://releases.hashicorp.com/vault/1.15.4/vault_1.15.4_linux_amd64.zip
          unzip vault.zip
          sudo mv vault /usr/local/bin/
          vault --version

      - name: Check and Create Vault Path
        id: check
        env:
          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
          VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
        run: |
          echo "Checking Vault path: ${{ env.VAULT_PATH }}"
          vault status || exit 1
          
          if vault kv get ${{ env.VAULT_PATH }} &> /dev/null; then
            echo "✓ Vault path exists"
            echo "ready=true" >> $GITHUB_OUTPUT
          else
            echo "⚠ Vault path does not exist, creating..."
            vault kv put ${{ env.VAULT_PATH }} \
              max_memory="128" \
              max_connections="1024" \
              port="11211" \
              threads="4" \
              max_item_size="1m" \
              version="1.6.23"
            echo "✓ Vault path created"
            echo "ready=true" >> $GITHUB_OUTPUT
          fi

  build-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: vault-init
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Vault CLI
        run: |
          wget -O vault.zip https://releases.hashicorp.com/vault/1.15.4/vault_1.15.4_linux_amd64.zip
          unzip vault.zip
          sudo mv vault /usr/local/bin/

      - name: Get Secrets from Vault
        id: secrets
        env:
          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
          VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
        run: |
          MAX_MEMORY=$(vault kv get -field=max_memory ${{ env.VAULT_PATH }})
          MAX_CONNECTIONS=$(vault kv get -field=max_connections ${{ env.VAULT_PATH }})
          PORT=$(vault kv get -field=port ${{ env.VAULT_PATH }})
          THREADS=$(vault kv get -field=threads ${{ env.VAULT_PATH }})
          MAX_ITEM_SIZE=$(vault kv get -field=max_item_size ${{ env.VAULT_PATH }})
          VERSION=$(vault kv get -field=version ${{ env.VAULT_PATH }})
          
          echo "max_memory=$MAX_MEMORY" >> $GITHUB_OUTPUT
          echo "max_connections=$MAX_CONNECTIONS" >> $GITHUB_OUTPUT
          echo "port=$PORT" >> $GITHUB_OUTPUT
          echo "threads=$THREADS" >> $GITHUB_OUTPUT
          echo "max_item_size=$MAX_ITEM_SIZE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./docker
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          build-args: |
            MEMCACHED_VERSION=${{ steps.secrets.outputs.version }}
            MEMCACHED_MAX_MEMORY=${{ steps.secrets.outputs.max_memory }}
            MEMCACHED_MAX_CONNECTIONS=${{ steps.secrets.outputs.max_connections }}
            MEMCACHED_PORT=${{ steps.secrets.outputs.port }}
            MEMCACHED_THREADS=${{ steps.secrets.outputs.threads }}
            MEMCACHED_MAX_ITEM_SIZE=${{ steps.secrets.outputs.max_item_size }}
